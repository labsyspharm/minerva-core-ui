import * as React from "react";
import { get, set } from 'idb-keyval';
import styled from 'styled-components';
import { useState, useEffect } from "react";
import { useHash } from "./lib/hashUtil";
import { hasFileSystemAccess, toDir, toLoader } from "./lib/filesystem";
import { isOpts, validate } from './lib/validate';
import { Upload } from './components/upload';
import { readConfig } from "./lib/exhibit";
import { Index } from "./components";

import type { ValidObj } from './components/upload';
import type { FormEventHandler } from "react";
import type { ObjAny, KV } from './lib/validate';
import type { Config } from "./lib/exhibit";
import type { ConfigWaypoint } from "./lib/exhibit";

type Props = {
  config: Config;
  handleKeys: string[];
};

interface ReduceFormData {
  (o: ObjAny, kv: KV): ObjAny;
}

const title = 'Primary Lung Cancer [M-003]';
const configWaypoints: ConfigWaypoint[] = [
  {
    "key": "A",
    "title": "Data Aquisition",
    "content": "Tissue cyclic immunofluorescence (t-CyCIF) was used to generate the fluorescence images.\n\nThe RareCyte CyteFinder microscope was used with a 40X/0.6NA objective.\n\nThe images were artifact corrected using the BaSiC tool, stitched and registered using the ASHLAR algorithm, \nand segmented using ilastik software and MATLAB. Single-cell features were then extracted from these images using HistoCAT software.\n\n![image](https://www.cycif.org/assets/img/du-lin-rashid-nat-protoc-2019/Fig1_Rashid_SciData.JPG)\n\nRead more about the t-CyCIF method and this data in the following papers:\n\n[Lin et al., eLife, 2018](https://elifesciences.org/articles/31657)\n\n[Du, Lin, and Rashid et al., Nature Methods, 2019](https://www-nature-com.ezp-prod1.hul.harvard.edu/articles/s41596-019-0206-y)\n\n[Rashid et al., Scientific Data, 2019](https://www-nature-com.ezp-prod1.hul.harvard.edu/articles/s41597-019-0332-y)\n"
  },
  {
    "key": "B",
    "title": "Cell Segmentation",
    "expanded": false,
    "content": "Cells in the image were segmented using an object detection method. Here, we used the Ilastik software\nto train a model that classifies pixels into three classes (nucleus, cytoplasm, and background). \nProbability masks generated by the model were used to perform morphological manipulations and \nwatershed in MATLAB to identify cells. \n\nWhile ~90% of the cells in this tissue are segmented accurately, there are some errors including \nfusions (undersegmented cells) and fissions (over segmented cells) as shown here.\nCell segmentation is a critical component of extracting quality single-cell data and \ncan affect the quality of downstream analysis; segmentation is thus an active area of development\nin the image analysis community.\n\nPan around the image and toggle the segmentation mask, or \"data layer\" below, to inspect the accuracy.\n"
  },
  {
    "key": "C",
    "title": "K-means Clustering",
    "expanded": false,
    "content": "When single cells are clustered based on their expression of `Keratin`, `a-SMA`, and `CD45` \nusing the k-means algorithm, the cells fall into four cardinal clusters `:` \n1) A cluster of tumor cells with high keratin expression, \n2) a cluster of stromal cells with high `a-SMA` expression, \n3) a cluster of immune cells with high `CD45` expression, and \n4) a cluster of cells with low expression of all three markers.\n\nClick on each square of the heatmap to see the corresponsing cluster and immunoflourescence channel.\n\n`VisMatrix`\n\nThe number of cells belonging to each cluster is shown in the bar chart.\n\n`VisBarChart`\n\nClick on each of the clusters below to see which cells in the image belong to each cluster. You can also click on each bar of the chart to \nsee corresponding cells in the image.\n"
  },
  {
    "key": "D",
    "title": "Scatter Plot",
    "expanded": false,
    "content": "\nThe Scatterplot shows log normalized mean instensities (au) of KERATIN and CD45 for a sample of cells.\nClick on a data point in the plot to be taken to the cell in the image.\n\n`VisScatterplot`\n\nClick on each of the clusters below to see which cells in the image belong to each cluster.\n"
  },
  {
    "key": "E",
    "title": "UMAP",
    "expanded": false,
    "content": "\nA random sample of 2000 cells were selected and Uniform Manifold Approximation and Projection for Dimension Reduction (UMAP) \nwas performed. Click on a data point in the plot to be taken to the cell in the image.\n\n`VisScatterplot`\n\nClick on each of the clusters below to see which cells in the image belong to each cluster.\n"
  },
  {
    "key": "F",
    "title": "t-SNE",
    "expanded": false,
    "content": "\nA random sample of 2000 cells were selected and t-Distributed Stochastic Neighbor Embedding (t-SNE) \nwas performed. Click on a data point in the plot to be taken to the cell in the image.\n\n`VisScatterplot`\n\nClick on each of the clusters below to see which cells in the image belong to each cluster.\n"
  },
  {
    "key": "G",
    "title": "Immune Populations",
    "expanded": false,
    "content": "Many immune populations are present in this lung cancer and are often \nenriched in the tumor region.\n\nWhen the subset of CD45 positive cells was clustered based on expression \nof CD45, CD3d, CD8A, CD4, CD20, PD1, and FOXP3 using k-means, \nseven distinct immune cell populations emerged.\n\nThe populations are shown in the heat map below, where each row represents \na cluster and each column represents an immune marker. \nThe color represents the expression level of each marker.\n"
  }
]; 

const Wrapper = styled.div`
  height: 100%;
  display: grid;
  grid-template-columns: 1fr auto 1fr; 
  grid-template-rows: 33vh 1fr 33vh; 
`;

const Full = styled.div`
  grid-row: 1 / -1;
  grid-column: 1 / -1;
`

const Scrollable = styled.div`
  z-index: 2;
  grid-column: 2;
  grid-row: 1 / -1;
  overflow-y: scroll;
  border-radius: 12px;
  background-color: hwb(220 10% 20% / .5);
  font-size: 20px;
  padding: 5vh;
  margin: 5vh;
`;

const Content = (props: Props) => {
  const { handleKeys } = props;
  const firstExhibit = readConfig(props.config);
  const [exhibit, setExhibit] = useState(firstExhibit);
  const [url, setUrl] = useState(window.location.href);
  const hashContext = useHash(url, exhibit.stories);
  const [handle, setHandle] = useState(null);
  const [loader, setLoader] = useState(null);
  const [fileName, setFileName] = useState('');
  // Create ome-tiff loader
  const onAllow = async () => {
    const newHandle = await toDir();
    setHandle(newHandle);
    await set(
      handleKeys[0], newHandle 
    );
  }
  const onRecall = async () => {
    const newHandle = await get(handleKeys[0])
    const isGranted = (permission) => permission === 'granted';
    const options = { mode: 'readwrite' };
    if (
      isGranted(await newHandle.queryPermission(options))
      || isGranted(await newHandle.requestPermission(options))
    ) {
      setHandle(newHandle);
    }
  }
  const onStart = (in_f: string) => {
    (async () => {
      if (handle === null) return;
      const loader = await toLoader({ handle, in_f });
      setLoader(loader.data);
      setFileName(in_f);
    })();
  }
  // Handle changes to URL
  useEffect(() => {
    window.addEventListener("hashchange", () => {
      setUrl(window.location.href);
    });
  }, [])

  // Actual image viewer
  const imager = loader === null ? '' : (
    <Full>
      <Index {...{
        title, configWaypoints, exhibit, setExhibit, loader,
        in_f: fileName, handle, ...hashContext
      }} />
    </Full>
  )

  const [valid, setValid] = useState({} as ValidObj);
  const onSubmit: FormEventHandler = (event) => {
    const form = event.currentTarget as HTMLFormElement;
    const data = [...new FormData(form).entries()];
    const formOut = data.reduce(((o, [k,v]) => {
      return { ...o, [k]: `${v}`};
    }) as ReduceFormData, {mask: ""});
    const filled = (form as any).checkValidity(); 
    const formOpts = { formOut, onStart, handle };
    if (isOpts(formOpts)) {
      validate(formOpts).then((valid: ValidObj) => {
        setValid(valid);
      })
    }
    event.preventDefault();
    event.stopPropagation();
  }
  const formProps = { onSubmit, valid };
  const uploadProps = {
    handleKeys, formProps, handle,
    onAllow, onRecall
  };

  const importer = loader !== null ? '' : (<Scrollable>
    <Upload {...uploadProps}/>
  </Scrollable>)
  return (
    <Wrapper>
      { imager }
      { importer }
    </Wrapper>
  );
};

const Main = (props: Props) => {
  if (hasFileSystemAccess()) {
    return <Content {...props}/>;
  }
  const error_message = `<p>
  Unable to access file system api.
  </p>`
  return <div>{error_message}</div>;
};


export { Main };
